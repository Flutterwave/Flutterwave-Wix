export declare const __debug: {
    verboseLogging: {
        on: () => boolean;
        off: () => boolean;
    };
};
export interface Secret {
    /**
     * The secret's unique ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * A unique, meaningful name used for retrieving the secret at runtime with the [`getSecretValue()`](#getsecretvalue) function. You can use alphanumeric characters and the following special characters: `_+=-@#$`. Spaces are not supported.
     *
     */
    name?: string | null;
    /** An optional text describing the secret's purpose or any other notes about it. */
    description?: string | null;
    /**
     * @internal
     * @internal */
    value?: string | null;
    /**
     * The date and time the secreted was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * The date and time the secret was last updated.
     * @readonly
     */
    _updatedDate?: Date;
}
export interface GetSecretValueRequest {
    /** The name of the secret to get the value of. */
    name: string;
}
export interface GetSecretValueResponse {
    /**
     * The plaintext, unencrypted value of the secret.
     *
     */
    value?: string;
}
export interface ListSecretInfoRequest {
}
export interface ListSecretInfoResponse {
    /** Object containing information for each secret.  */
    secrets?: Secret[];
}
export interface CreateSecretRequest {
    /** The object including the fields of a new secret.  */
    secret: Secret;
}
export interface CreateSecretResponse {
    /**
     * The globally-unique ID assigned to the secret.
     *
     */
    _id?: string;
}
export interface DeleteSecretRequest {
    /**
     * The unique ID of the secret to be deleted.
     *
     */
    _id: string;
}
export interface DeleteSecretResponse {
}
export interface UpdateSecretRequest {
    /** The unique ID of the secret to be updated. */
    _id: string;
    /** The secret fields to update. */
    secret: Secret;
}
export interface UpdateSecretResponse {
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp. */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entityAsJson?: string;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntityAsJson?: string | null;
}
export interface ActionEvent {
    bodyAsJson?: string;
}
export interface GetSecretValueResponseNonNullableFields {
    value: string;
}
export interface ListSecretInfoResponseNonNullableFields {
    secrets: Secret[];
}
export interface CreateSecretResponseNonNullableFields {
    _id: string;
}
/**
 * Retrieves the secret value specified by the secret name.
 *
 * The `getSecretValue()` function returns a Promise that resolves to the value of the secret with the specified given name.
 *
 * >**Note:**
 * > Only use a secret's value in the backend code. Returning the secret value in the frontend is a security risk.
 * @public
 * @documentationMaturity preview
 * @requiredField name
 * @param name - The name of the secret to get the value of.
 * @returns Fulfilled - The value of the secret. Rejected - Error message.
 */
export declare function getSecretValue(name: string): Promise<GetSecretValueResponse & GetSecretValueResponseNonNullableFields>;
/**
 * Retrieves a list of objects containing information about all secrets.
 *
 * The `listSecretInfo()` function returns a Promise that resolves to a list containing information about all secrets stored on your site.
 *
 * > **Note:**
 * > - The secret's value does not get returned for security reasons. To retrieve a secret's value, use the [`getSecretValue()`](#getSecretValue) function.
 * @public
 * @documentationMaturity preview
 * @returns Fulfilled - A list of objects containing information about your site's secrets. Rejected - Error message.
 */
export declare function listSecretInfo(): Promise<ListSecretInfoResponse & ListSecretInfoResponseNonNullableFields>;
/**
 * Creates a new secret.
 *
 * The `createSecret()` function returns a Promise that resolves secret ID when the secret is created.
 *
 * >**Notes:**
 * > - The secret's name cannot start with `'wix'` or be identical to an existing secret's name.
 * > - Don't leave private keys in your code. Leaving them in your code is a security risk. Make sure to delete the keys from the code after running `createSecret()`.
 * @public
 * @documentationMaturity preview
 * @requiredField secret
 * @requiredField secret.name
 * @requiredField secret.value
 * @param secret - Fields of a new secret.
 * @returns Fulfilled - The ID of the created secret.
 * Rejected - Error message.
 */
export declare function createSecret(secret: Secret): Promise<string>;
/**
 * Deletes an existing secret by ID.
 *
 * The `deleteSecret()` function returns a Promise that resolves when the secret is deleted. You can retrieve the secret `_id` using the [`listSecretInfo()`](#listsecretinfo) function.
 *
 * >**Note:**
 * > Deleting a secret is irreversible and will break all code using the secret.
 *
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @param _id - The unique ID of the secret to be deleted.
 * @returns Fulfilled - When the secret is successfully deleted. Rejected - Error message.
 */
export declare function deleteSecret(_id: string): Promise<void>;
/**
 * Updates the specified fields of an existing secret by ID.
 *
 *
 * The `updateSecret()` function returns a Promise that resolves when the secret is successfully updated. You can update one or more fields. Only fields passed in the `secret` object will be updated. All other properties will remain unchanged.
 *
 * You can retrieve the `_id` parameter from the [`listSecretInfo()`](#listsecretinfo) function. The secret `_id` is different from the secret `name` used by the [`getSecretValue()`](#getsecretvalue) function.
 *
 * > **Notes:**
 * > - Changing a secret's name or value will break all code using the secret.
 * > - You can't rename the secret with a name of an existing secret.
 * > - Don't leave private keys in your code! Leaving them in is a security risk. Make sure to delete the keys from the code after running `updateSecret()`.
 * @param _id - The unique ID of the secret to be updated.
 * @param secret - The secret fields to update.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField secret
 * @returns Fulfilled - When the secret is updated.
 * Rejected - Error message.
 */
export declare function updateSecret(_id: string, secret: Secret): Promise<void>;
